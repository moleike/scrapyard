// automatically generated by the FlatBuffers compiler, do not modify
// @generated
extern crate alloc;


#[allow(unused_imports, dead_code)]
pub mod messages {


#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_COMMAND: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_COMMAND: u8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COMMAND: [Command; 4] = [
  Command::NONE,
  Command::Set,
  Command::Delete,
  Command::Get,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Command(pub u8);
#[allow(non_upper_case_globals)]
impl Command {
  pub const NONE: Self = Self(0);
  pub const Set: Self = Self(1);
  pub const Delete: Self = Self(2);
  pub const Get: Self = Self(3);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Set,
    Self::Delete,
    Self::Get,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Set => Some("Set"),
      Self::Delete => Some("Delete"),
      Self::Get => Some("Get"),
      _ => None,
    }
  }
}
impl ::core::fmt::Debug for Command {
  fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> ::flatbuffers::Follow<'a> for Command {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { ::flatbuffers::read_scalar_at::<u8>(buf, loc) };
    Self(b)
  }
}

impl ::flatbuffers::Push for Command {
    type Output = Command;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { ::flatbuffers::emplace_scalar::<u8>(dst, self.0) };
    }
}

impl ::flatbuffers::EndianScalar for Command {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> ::flatbuffers::Verifiable for Command {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    u8::run_verifier(v, pos)
  }
}

impl ::flatbuffers::SimpleToVerifyInSlice for Command {}
pub struct CommandUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ERROR_CODE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ERROR_CODE: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ERROR_CODE: [ErrorCode; 3] = [
  ErrorCode::Unknown,
  ErrorCode::NotFound,
  ErrorCode::StorageFull,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ErrorCode(pub i8);
#[allow(non_upper_case_globals)]
impl ErrorCode {
  pub const Unknown: Self = Self(0);
  pub const NotFound: Self = Self(1);
  pub const StorageFull: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Unknown,
    Self::NotFound,
    Self::StorageFull,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Unknown => Some("Unknown"),
      Self::NotFound => Some("NotFound"),
      Self::StorageFull => Some("StorageFull"),
      _ => None,
    }
  }
}
impl ::core::fmt::Debug for ErrorCode {
  fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> ::flatbuffers::Follow<'a> for ErrorCode {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { ::flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl ::flatbuffers::Push for ErrorCode {
    type Output = ErrorCode;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { ::flatbuffers::emplace_scalar::<i8>(dst, self.0) };
    }
}

impl ::flatbuffers::EndianScalar for ErrorCode {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> ::flatbuffers::Verifiable for ErrorCode {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    i8::run_verifier(v, pos)
  }
}

impl ::flatbuffers::SimpleToVerifyInSlice for ErrorCode {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_REPLY: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_REPLY: u8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_REPLY: [Reply; 4] = [
  Reply::NONE,
  Reply::Success,
  Reply::Failure,
  Reply::GetValue,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Reply(pub u8);
#[allow(non_upper_case_globals)]
impl Reply {
  pub const NONE: Self = Self(0);
  pub const Success: Self = Self(1);
  pub const Failure: Self = Self(2);
  pub const GetValue: Self = Self(3);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Success,
    Self::Failure,
    Self::GetValue,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Success => Some("Success"),
      Self::Failure => Some("Failure"),
      Self::GetValue => Some("GetValue"),
      _ => None,
    }
  }
}
impl ::core::fmt::Debug for Reply {
  fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> ::flatbuffers::Follow<'a> for Reply {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { ::flatbuffers::read_scalar_at::<u8>(buf, loc) };
    Self(b)
  }
}

impl ::flatbuffers::Push for Reply {
    type Output = Reply;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { ::flatbuffers::emplace_scalar::<u8>(dst, self.0) };
    }
}

impl ::flatbuffers::EndianScalar for Reply {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> ::flatbuffers::Verifiable for Reply {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    u8::run_verifier(v, pos)
  }
}

impl ::flatbuffers::SimpleToVerifyInSlice for Reply {}
pub struct ReplyUnionTableOffset {}

pub enum SetOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Set<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Set<'a> {
  type Inner = Set<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Set<'a> {
  pub const VT_KEY: ::flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: ::flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Set { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SetArgs<'args>
  ) -> ::flatbuffers::WIPOffset<Set<'bldr>> {
    let mut builder = SetBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Set::VT_KEY, None)}
  }
  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Set::VT_VALUE, None)}
  }
}

impl ::flatbuffers::Verifiable for Set<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct SetArgs<'a> {
    pub key: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<::flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SetArgs<'a> {
  #[inline]
  fn default() -> Self {
    SetArgs {
      key: None,
      value: None,
    }
  }
}

pub struct SetBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> SetBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Set::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Set::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> SetBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SetBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Set<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Set<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Set");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum DeleteOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Delete<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Delete<'a> {
  type Inner = Delete<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Delete<'a> {
  pub const VT_KEY: ::flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Delete { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DeleteArgs<'args>
  ) -> ::flatbuffers::WIPOffset<Delete<'bldr>> {
    let mut builder = DeleteBuilder::new(_fbb);
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Delete::VT_KEY, None)}
  }
}

impl ::flatbuffers::Verifiable for Delete<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
     .finish();
    Ok(())
  }
}
pub struct DeleteArgs<'a> {
    pub key: Option<::flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DeleteArgs<'a> {
  #[inline]
  fn default() -> Self {
    DeleteArgs {
      key: None,
    }
  }
}

pub struct DeleteBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> DeleteBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Delete::VT_KEY, key);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> DeleteBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DeleteBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Delete<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Delete<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Delete");
      ds.field("key", &self.key());
      ds.finish()
  }
}
pub enum GetOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Get<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Get<'a> {
  type Inner = Get<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Get<'a> {
  pub const VT_KEY: ::flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Get { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GetArgs<'args>
  ) -> ::flatbuffers::WIPOffset<Get<'bldr>> {
    let mut builder = GetBuilder::new(_fbb);
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Get::VT_KEY, None)}
  }
}

impl ::flatbuffers::Verifiable for Get<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
     .finish();
    Ok(())
  }
}
pub struct GetArgs<'a> {
    pub key: Option<::flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for GetArgs<'a> {
  #[inline]
  fn default() -> Self {
    GetArgs {
      key: None,
    }
  }
}

pub struct GetBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> GetBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Get::VT_KEY, key);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> GetBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GetBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Get<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Get<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Get");
      ds.field("key", &self.key());
      ds.finish()
  }
}
pub enum RequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Request<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Request<'a> {
  type Inner = Request<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Request<'a> {
  pub const VT_COMMAND_TYPE: ::flatbuffers::VOffsetT = 4;
  pub const VT_COMMAND: ::flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Request { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RequestArgs
  ) -> ::flatbuffers::WIPOffset<Request<'bldr>> {
    let mut builder = RequestBuilder::new(_fbb);
    if let Some(x) = args.command { builder.add_command(x); }
    builder.add_command_type(args.command_type);
    builder.finish()
  }


  #[inline]
  pub fn command_type(&self) -> Command {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Command>(Request::VT_COMMAND_TYPE, Some(Command::NONE)).unwrap()}
  }
  #[inline]
  pub fn command(&self) -> Option<::flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Table<'a>>>(Request::VT_COMMAND, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_set(&self) -> Option<Set<'a>> {
    if self.command_type() == Command::Set {
      self.command().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Set::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_delete(&self) -> Option<Delete<'a>> {
    if self.command_type() == Command::Delete {
      self.command().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Delete::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_get(&self) -> Option<Get<'a>> {
    if self.command_type() == Command::Get {
      self.command().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Get::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl ::flatbuffers::Verifiable for Request<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_union::<Command, _>("command_type", Self::VT_COMMAND_TYPE, "command", Self::VT_COMMAND, false, |key, v, pos| {
        match key {
          Command::Set => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Set>>("Command::Set", pos),
          Command::Delete => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Delete>>("Command::Delete", pos),
          Command::Get => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Get>>("Command::Get", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct RequestArgs {
    pub command_type: Command,
    pub command: Option<::flatbuffers::WIPOffset<::flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for RequestArgs {
  #[inline]
  fn default() -> Self {
    RequestArgs {
      command_type: Command::NONE,
      command: None,
    }
  }
}

pub struct RequestBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> RequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_command_type(&mut self, command_type: Command) {
    self.fbb_.push_slot::<Command>(Request::VT_COMMAND_TYPE, command_type, Command::NONE);
  }
  #[inline]
  pub fn add_command(&mut self, command: ::flatbuffers::WIPOffset<::flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Request::VT_COMMAND, command);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> RequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Request<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Request<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Request");
      ds.field("command_type", &self.command_type());
      match self.command_type() {
        Command::Set => {
          if let Some(x) = self.command_as_set() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::Delete => {
          if let Some(x) = self.command_as_delete() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Command::Get => {
          if let Some(x) = self.command_as_get() {
            ds.field("command", &x)
          } else {
            ds.field("command", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("command", &x)
        },
      };
      ds.finish()
  }
}
pub enum FailureOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Failure<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Failure<'a> {
  type Inner = Failure<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Failure<'a> {
  pub const VT_CODE: ::flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Failure { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FailureArgs
  ) -> ::flatbuffers::WIPOffset<Failure<'bldr>> {
    let mut builder = FailureBuilder::new(_fbb);
    builder.add_code(args.code);
    builder.finish()
  }


  #[inline]
  pub fn code(&self) -> ErrorCode {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ErrorCode>(Failure::VT_CODE, Some(ErrorCode::Unknown)).unwrap()}
  }
}

impl ::flatbuffers::Verifiable for Failure<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<ErrorCode>("code", Self::VT_CODE, false)?
     .finish();
    Ok(())
  }
}
pub struct FailureArgs {
    pub code: ErrorCode,
}
impl<'a> Default for FailureArgs {
  #[inline]
  fn default() -> Self {
    FailureArgs {
      code: ErrorCode::Unknown,
    }
  }
}

pub struct FailureBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> FailureBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_code(&mut self, code: ErrorCode) {
    self.fbb_.push_slot::<ErrorCode>(Failure::VT_CODE, code, ErrorCode::Unknown);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> FailureBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FailureBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Failure<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Failure<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Failure");
      ds.field("code", &self.code());
      ds.finish()
  }
}
pub enum GetValueOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetValue<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for GetValue<'a> {
  type Inner = GetValue<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> GetValue<'a> {
  pub const VT_VALUE: ::flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    GetValue { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GetValueArgs<'args>
  ) -> ::flatbuffers::WIPOffset<GetValue<'bldr>> {
    let mut builder = GetValueBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(GetValue::VT_VALUE, None)}
  }
}

impl ::flatbuffers::Verifiable for GetValue<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct GetValueArgs<'a> {
    pub value: Option<::flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for GetValueArgs<'a> {
  #[inline]
  fn default() -> Self {
    GetValueArgs {
      value: None,
    }
  }
}

pub struct GetValueBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> GetValueBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_value(&mut self, value: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(GetValue::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> GetValueBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GetValueBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<GetValue<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for GetValue<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("GetValue");
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum SuccessOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Success<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Success<'a> {
  type Inner = Success<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Success<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Success { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    _args: &'args SuccessArgs
  ) -> ::flatbuffers::WIPOffset<Success<'bldr>> {
    let mut builder = SuccessBuilder::new(_fbb);
    builder.finish()
  }

}

impl ::flatbuffers::Verifiable for Success<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct SuccessArgs {
}
impl<'a> Default for SuccessArgs {
  #[inline]
  fn default() -> Self {
    SuccessArgs {
    }
  }
}

pub struct SuccessBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> SuccessBuilder<'a, 'b, A> {
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> SuccessBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SuccessBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Success<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Success<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Success");
      ds.finish()
  }
}
pub enum ResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Response<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Response<'a> {
  type Inner = Response<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Response<'a> {
  pub const VT_REPLY_TYPE: ::flatbuffers::VOffsetT = 4;
  pub const VT_REPLY: ::flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Response { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ResponseArgs
  ) -> ::flatbuffers::WIPOffset<Response<'bldr>> {
    let mut builder = ResponseBuilder::new(_fbb);
    if let Some(x) = args.reply { builder.add_reply(x); }
    builder.add_reply_type(args.reply_type);
    builder.finish()
  }


  #[inline]
  pub fn reply_type(&self) -> Reply {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Reply>(Response::VT_REPLY_TYPE, Some(Reply::NONE)).unwrap()}
  }
  #[inline]
  pub fn reply(&self) -> Option<::flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Table<'a>>>(Response::VT_REPLY, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn reply_as_success(&self) -> Option<Success<'a>> {
    if self.reply_type() == Reply::Success {
      self.reply().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Success::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn reply_as_failure(&self) -> Option<Failure<'a>> {
    if self.reply_type() == Reply::Failure {
      self.reply().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Failure::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn reply_as_get_value(&self) -> Option<GetValue<'a>> {
    if self.reply_type() == Reply::GetValue {
      self.reply().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GetValue::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl ::flatbuffers::Verifiable for Response<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_union::<Reply, _>("reply_type", Self::VT_REPLY_TYPE, "reply", Self::VT_REPLY, false, |key, v, pos| {
        match key {
          Reply::Success => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Success>>("Reply::Success", pos),
          Reply::Failure => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<Failure>>("Reply::Failure", pos),
          Reply::GetValue => v.verify_union_variant::<::flatbuffers::ForwardsUOffset<GetValue>>("Reply::GetValue", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct ResponseArgs {
    pub reply_type: Reply,
    pub reply: Option<::flatbuffers::WIPOffset<::flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for ResponseArgs {
  #[inline]
  fn default() -> Self {
    ResponseArgs {
      reply_type: Reply::NONE,
      reply: None,
    }
  }
}

pub struct ResponseBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> ResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_reply_type(&mut self, reply_type: Reply) {
    self.fbb_.push_slot::<Reply>(Response::VT_REPLY_TYPE, reply_type, Reply::NONE);
  }
  #[inline]
  pub fn add_reply(&mut self, reply: ::flatbuffers::WIPOffset<::flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Response::VT_REPLY, reply);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> ResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Response<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Response<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Response");
      ds.field("reply_type", &self.reply_type());
      match self.reply_type() {
        Reply::Success => {
          if let Some(x) = self.reply_as_success() {
            ds.field("reply", &x)
          } else {
            ds.field("reply", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Reply::Failure => {
          if let Some(x) = self.reply_as_failure() {
            ds.field("reply", &x)
          } else {
            ds.field("reply", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Reply::GetValue => {
          if let Some(x) = self.reply_as_get_value() {
            ds.field("reply", &x)
          } else {
            ds.field("reply", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("reply", &x)
        },
      };
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Response`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_response_unchecked`.
pub fn root_as_response(buf: &[u8]) -> Result<Response<'_>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::root::<Response>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Response` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_response_unchecked`.
pub fn size_prefixed_root_as_response(buf: &[u8]) -> Result<Response<'_>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::size_prefixed_root::<Response>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Response` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_response_unchecked`.
pub fn root_as_response_with_opts<'b, 'o>(
  opts: &'o ::flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Response<'b>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::root_with_opts::<Response<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Response` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_response_unchecked`.
pub fn size_prefixed_root_as_response_with_opts<'b, 'o>(
  opts: &'o ::flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Response<'b>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::size_prefixed_root_with_opts::<Response<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Response and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Response`.
pub unsafe fn root_as_response_unchecked(buf: &[u8]) -> Response<'_> {
  unsafe { ::flatbuffers::root_unchecked::<Response>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Response and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Response`.
pub unsafe fn size_prefixed_root_as_response_unchecked(buf: &[u8]) -> Response<'_> {
  unsafe { ::flatbuffers::size_prefixed_root_unchecked::<Response>(buf) }
}
#[inline]
pub fn finish_response_buffer<'a, 'b, A: ::flatbuffers::Allocator + 'a>(
    fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
    root: ::flatbuffers::WIPOffset<Response<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_response_buffer<'a, 'b, A: ::flatbuffers::Allocator + 'a>(fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>, root: ::flatbuffers::WIPOffset<Response<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod Messages

